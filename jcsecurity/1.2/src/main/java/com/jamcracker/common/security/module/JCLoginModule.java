/* * Class: BaseLoginModule * * Comments for Developers Only: * * Version History: *  * Ver  Date         Who                Release     What and Why * ---  ----------   ----------         -------     --------------------------------------- * 1.0  09/02/2010   Shireesh			1.0			Componentized from TSM code <<//jaws/TS_Marketplace/trunk/src/java/core/com/jamcracker/tsmarketplace/security/authentication/jaas/loginmodule/BaseLoginModule.java>> * 2.0  22/11/2011   Veena				1.1			Changes made for SSO Implementation * This software is the confidential and proprietary information of Jamcracker, Inc.  * ("Confidential Information").  You shall not disclose such Confidential Information *  and shall use it only in accordance with the terms of the license agreement you  *  entered into with Jamcracker, Inc. Copyright (c) 2000 Jamcracker, Inc.  All Rights     *  Reserved * * *  ******************************************************/package com.jamcracker.common.security.module;import java.util.ArrayList;import java.util.Hashtable;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import javax.security.auth.Subject;import javax.security.auth.callback.Callback;import javax.security.auth.callback.CallbackHandler;import javax.security.auth.login.LoginException;import javax.security.auth.spi.LoginModule;import com.jamcracker.api.AuthenticationAPI;import com.jamcracker.api.JCAPIFactory;import com.jamcracker.api.UserAPI;import com.jamcracker.api.common.APIConstants;import com.jamcracker.api.common.exception.JCApiException;import com.jamcracker.api.search.UserSearchInfo;import com.jamcracker.common.exception.JCDynamicFaultCode;import com.jamcracker.common.exception.JCFaultCode;import com.jamcracker.common.security.ClientType;import com.jamcracker.common.security.authentication.jaas.JAASConstants;import com.jamcracker.common.security.authorization.JCPPrivilege;import com.jamcracker.common.security.authorization.JCPRole;import com.jamcracker.common.security.authorization.JCPRoleDetails;import com.jamcracker.common.security.authorization.jaas.policy.PrivilegePrincipal;import com.jamcracker.common.security.constants.JCSecurityConstants;import com.jamcracker.common.security.exception.SecurityException;import com.jamcracker.common.security.exception.SecurityFaultCode;import com.jamcracker.common.security.facade.dao.ISecurityDAO;import com.jamcracker.common.security.facade.dataobject.RBACUserRole;import com.jamcracker.common.security.facade.dataobject.UserRole;import com.jamcracker.common.security.spec.ISecureSession;import com.jamcracker.common.security.util.JCRolePrivilegeUtil;import com.jamcracker.common.security.util.SpringConfigLoader;import com.jamcracker.directory.company.facade.CompanyFacade;import com.jamcracker.directory.dataobject.CompanyShortInfo;import com.jamcracker.directory.dataobject.UserInfo;import com.jamcracker.directory.dataobject.UserShortInfo;import com.jamcracker.directory.user.facade.UserFacade;import com.jamcracker.jcri.FacadeFactory;import com.jamcracker.security.authentication.AuthenticationToken;import com.jamcracker.security.authentication.jaas.callback.CredentialCallback;import com.jamcracker.security.identity.Identity;/** *  * The basic login module implementation. The users extending this class should *  * provide implementation for "isValidUser" method. */public  class JCLoginModule implements LoginModule {	public static final boolean LOGIN_SUCCESS = true;	public static final boolean LOGIN_FAILURE = false;	private static org.apache.log4j.Logger LOGGER = org.apache.log4j.Logger	.getLogger(JCLoginModule.class.getName());	protected String companyAcronym;	protected String userId;	protected String password;	protected String isProxy;	protected int storeCompanyId;	protected String instanceId;	protected int eorgCompanyId;	protected CallbackHandler callbackHandler;	protected Subject subject;	protected Map sharedState;	protected Map options;	protected String ssoSessionId;	protected String requester;	protected String authType;	protected Map loginMap;	boolean loginSuccessful = false;		private static final String DEFAULT_LANGUAGE_CODE = "en_US";	private ClientType clientType = ClientType.UI;	private UserInfo user = null;	private UserRole userRole = null;	private RBACUserRole rBACUserRole = null;	private CompanyShortInfo organization = null;	private JCPRole jcpRole = null;	private JCPRoleDetails roleDetails = null;	private Identity identity = null;	private UserShortInfo usrShortInfo = null;		@Override	public void initialize(Subject subject, CallbackHandler callbackHandler,	Map sharedState, Map options) {		this.callbackHandler = callbackHandler;		this.subject = subject;		this.sharedState = sharedState;		this.options = options;	}	public boolean login() throws LoginException {		if (LOGGER.isDebugEnabled()) {			LOGGER.debug("start login() Method of BaseLoginModule ");		}		if (callbackHandler == null) {			throw new LoginException("Error: no CallbackHandler provided.");		}		LOGGER.info("callback handler" + callbackHandler.getClass());		try {			Callback[] Callbacks = new Callback[] {			new CredentialCallback(JAASConstants.MAPCALLBACK) };			try {				callbackHandler.handle(Callbacks);				loginMap = (Map) ((CredentialCallback) Callbacks[0])						.getCredential();								if (loginMap != null) {						loginSuccessful = isValidUser(loginMap);				}																		} catch (SecurityException se) {				loginSuccessful = false;				/*				 * 				 * It catches the SecurityException and compare with FaultCode				 * to identify if it is AD Authentication Error				 * 				 * LoginException does not provide any constructor for error				 * code, so error code and message is passed in the same				 * 				 * string with separator ||				 */				if (se.getFaultCode().getCode()						.equals(SecurityFaultCode.AD_AUTH_ERROR.getCode()))				{					JCFaultCode fc = se.getFaultCode();					if (fc instanceof JCDynamicFaultCode) {						JCDynamicFaultCode dfc = (JCDynamicFaultCode) fc;						throw new LoginException(se.getFaultCode().toString()								+ "||" + dfc.getArguments().get(0));					}				}				throw new LoginException(						SecurityFaultCode.LOGIN_FAILURE.toString());			}		} catch (Exception ex) {			loginSuccessful = false;			LOGGER.error(" Invalid Access " + ex);			throw new LoginException(SecurityFaultCode.INVALID_ACCESS.getCode());		}		if (LOGGER.isDebugEnabled()) {			LOGGER.debug("loginSuccessful = " + loginSuccessful);		}		if (LOGGER.isDebugEnabled()) {			LOGGER.debug("end login() Method of BaseLoginModule ");		}		return loginSuccessful;	}	@Override	public boolean abort() throws LoginException {		return logout();	}	@Override	public boolean logout() throws LoginException {		if (LOGGER.isDebugEnabled()) {			LOGGER.debug("start logout() Method of BaseLoginModule ");		}		if (loginSuccessful) {			Set curPrincipals = subject.getPrincipals();			if (curPrincipals != null) {				curPrincipals.clear();			}			loginSuccessful = false;		}		if (LOGGER.isDebugEnabled()) {			LOGGER.debug("end logout() Method of BaseLoginModule ");		}		return true;	}		/**	 * true if this method succeeded, or false if this LoginModule should be	 * ignored	 */	@Override	public boolean commit() throws LoginException {		LOGGER.debug(" start commit() Method of JCLoginModule ");				ISecurityDAO securityDAO = (ISecurityDAO) SpringConfigLoader.getBean(JCSecurityConstants.JC_SECURITY_DAO);		try {			user = new UserInfo();			//temporarily fix for bugid=12359 , needed permanent fix for bugid 12536  , Proxy  Should happen with MarketPlace companyID/Super Admin CompanyID.			if(loginMap.get(JAASConstants.PARENT_COMPANY_ID) != null)			{				storeCompanyId = ((Integer) loginMap.get(JAASConstants.PARENT_COMPANY_ID)).intValue();			}		    			//storeCompanyId=identity.getCompanyID();   			UserFacade userFacade = FacadeFactory.getInstance().getUserFacade();			int luserId = usrShortInfo.getUserID();			int pivotPathroleId = usrShortInfo.getUserRoleID();			LOGGER.debug("User id found value is : " + userId);			LOGGER.debug("User PivotPath role found value is : "+ pivotPathroleId);					user.setUserID(luserId);			user = userFacade.getUserInfo(luserId);			int orgId = -1;			//rbacOrgId will have user company id which is used to pass as constructor argument for PrivilegePrincipal			int rbacOrgId = -1;            if(loginMap.get(JAASConstants.IS_PROXY)!=null && ((Boolean)loginMap.get(JAASConstants.IS_PROXY)).booleanValue() == true)            {				orgId = (Integer)loginMap.get(JAASConstants.E_ORG_COMPANY_ID);				rbacOrgId = (Integer)loginMap.get(JAASConstants.E_ORG_COMPANY_ID);			            }			else{				 orgId = user.getCompanyID();				 rbacOrgId = user.getCompanyID();						}			CompanyFacade companyFacade = FacadeFactory.getInstance()					.getCompanyFacade();			organization = companyFacade.getCompanyShortInfo(orgId);			jcpRole = securityDAO.getRole(pivotPathroleId);			roleDetails = securityDAO.getRoleDetails(pivotPathroleId,					DEFAULT_LANGUAGE_CODE);			userRole = UserRole.extractRole(pivotPathroleId);			JCPPrivilege jcpPrivilege = null;			List<JCPPrivilege> jcpRolePrivileges = new ArrayList<JCPPrivilege>();			/* instanceId is not null then populate permission list in subject for cloud instances  			 */			if(instanceId == null || JAASConstants.EMPTY_STRING.equals(instanceId)){				//Loading jsdn privileges.....                if(loginMap.get(JAASConstants.IS_PROXY)!=null &&  ((Boolean)loginMap.get(JAASConstants.IS_PROXY)).booleanValue() == true)                {						/*orgId = eorgCompanyId;					rbacOrgId = eorgCompanyId;*/					orgId = (Integer)loginMap.get(JAASConstants.E_ORG_COMPANY_ID);					rbacOrgId = (Integer)loginMap.get(JAASConstants.E_ORG_COMPANY_ID);					rBACUserRole = securityDAO.getProxyAclRoleId(orgId);						    	}else if(JAASConstants.GUEST_USER_ID == luserId){					rBACUserRole = securityDAO.getGuestAclRoleId(storeCompanyId);					/* Set rbacOrgId as store company id If guest user is logged in 					since the privileges are defined at store level for guest user */					rbacOrgId = storeCompanyId;				}else					rBACUserRole = securityDAO.getAclRoleId(luserId);				if(rBACUserRole!=null){					LOGGER.debug(" ACL Role is available");					jcpRolePrivileges.addAll(securityDAO.getRolePrivileges(rBACUserRole.getRoleId()));				}				else					rBACUserRole = new RBACUserRole();				jcpRolePrivileges.addAll(jcpRole.getPrivileges());				LOGGER.debug(" jcpRolePrivileges for jsdn in JCLoginmodule... "+jcpRolePrivileges);				Iterator<JCPPrivilege> privilegesIt = jcpRolePrivileges.iterator();				while (privilegesIt.hasNext()) {					jcpPrivilege = privilegesIt.next();					/**					 * Get and add the privilege.					 */					subject.getPrincipals().add(							new PrivilegePrincipal(jcpPrivilege.getPrivilegeId(), jcpPrivilege.getName(),rbacOrgId));				}				if (clientType.equals(ClientType.UI)) {					identity.getAuthenticationToken().setClientType(							APIConstants.UI_CLIENT);					populatePublicCredentials(subject);				} else {					identity.getAuthenticationToken().setClientType(							APIConstants.API_CLIENT);					populatePublicCredentials(subject);				}			}			else{				//Loading cloud privileges based on instance id.....				Integer instanceRoleId = securityDAO.getInstanceRoleId(luserId,instanceId);				jcpRolePrivileges.addAll(securityDAO.getRolePrivileges(instanceRoleId));				jcpRolePrivileges.addAll(jcpRole.getPrivileges());				LOGGER.debug(" jcpRolePrivileges for cloud in JCLoginmodule... "+jcpRolePrivileges);				Iterator<JCPPrivilege> privilegesIt = jcpRolePrivileges.iterator();				while (privilegesIt.hasNext()) {					jcpPrivilege = privilegesIt.next();					subject.getPrincipals().add(							new PrivilegePrincipal(jcpPrivilege.getPrivilegeId(), jcpPrivilege.getName(),rbacOrgId,instanceId));				}			}			LOGGER.debug(" LOGIN_SUCCESS value in commit method "+ LOGIN_SUCCESS);			LOGGER.debug(" end commit() Method of JCLoginModule ");			return LOGIN_SUCCESS;		} catch (Exception e) {			LOGGER.error("Error while updating user privileges", e);		}		LOGGER.debug(" LOGIN_SUCCESS value in commit method "+ LOGIN_SUCCESS);		return LOGIN_FAILURE;	}	private void populatePublicCredentials(Subject subject) {		if (LOGGER.isDebugEnabled()) {			LOGGER					.debug(" start populatePublicCredentials() Method of JCLoginModule ");		}		Map<String, Object> userContextMap = new Hashtable<String, Object>();		userContextMap.put(ISecureSession.PIVOT_PATH_IDENTITY, identity);		userContextMap.put(ISecureSession.USER_SECURITY_SHORT_INFO,				usrShortInfo);		userContextMap.put(ISecureSession.USER_ROLE, jcpRole);		userContextMap.put(ISecureSession.USER_ROLE_DETAILS, roleDetails);		userContextMap.put(ISecureSession.USER, user);		userContextMap.put(ISecureSession.USER_JC_ROLE, userRole);		userContextMap.put(ISecureSession.USER_ORGANIZATION, organization);		userContextMap.put(ISecureSession.RBAC_USER_ROLE, rBACUserRole);		subject.getPublicCredentials().add(userContextMap);		if (LOGGER.isDebugEnabled()) {			LOGGER					.debug(" end populatePublicCredentials() Method of JCLoginModule ");		}	}	private void populateGuestCredentials(Subject subject) {		if (LOGGER.isDebugEnabled()) {			LOGGER					.debug(" start populateGuestCredentials() Method of JCLoginModule ");		}		userRole = UserRole.DEFAULT;		JCPPrivilege jcpPrivilege = null;		List<JCPPrivilege> jcpRolePrivileges = JCRolePrivilegeUtil				.getRolePrivileges(userRole, null);		Iterator<JCPPrivilege> privilegesIt = jcpRolePrivileges.iterator();		while (privilegesIt.hasNext()) {			jcpPrivilege = privilegesIt.next();			/**			 * Get and add the privilege.			 */			subject.getPrincipals().add(					new PrivilegePrincipal(jcpPrivilege.getName()));		}		Map<String, Object> userContextMap = new Hashtable<String, Object>();		userContextMap.put(ISecureSession.USER_JC_ROLE, userRole);		subject.getPublicCredentials().add(userContextMap);		if (LOGGER.isDebugEnabled()) {			LOGGER					.debug(" end populateGuestCredentials() Method of JCLoginModule ");		}	}			public boolean isValidUser(Map credentials) throws SecurityException {		List<UserShortInfo> userSearchList = null;				AuthenticationToken authToken = null;		usrShortInfo = new UserShortInfo();		if (LOGGER.isDebugEnabled()) {			LOGGER.debug(" start isValidUser() Method of JCLoginModule ");		}		try {			AuthenticationAPI authAPI = JCAPIFactory.getAuthenticationAPI();						instanceId = (String) credentials.get(JAASConstants.INSTANCE_ID);						/*			 * if login is for cloud instance, instance id is not null and			 * 			 * logged in user authentication token used for to validating the token,			 * 			 * to check api request is valid or not.			 */			if(instanceId == null || JAASConstants.EMPTY_STRING.equals(instanceId)) {				/*				 * Author: Dheeraj Nagwani				 * Reason: Checking the existing authToken. If present and valid, using the same.				 * This is required for AD/SAML based Enterprises to be able to be able to				 * do proxy.				 * 				 * Without this, it will try to re-authenticate the user with the external				 * server (AD or IDP) and fail as the password in the DB may not match				 * with the external server (AD or IDP).				 * 				 * This will also work for a normal reseller / marketplace admin trying to 				 * proxy. It will not re-authenticate if the AuthToken from the marketplace is				 * still valid.				 * 				 */				identity = (Identity) credentials.get(JAASConstants.IDENTITY);				if (identity != null) {					authToken = identity.getAuthenticationToken();				}								boolean isValidToken = false;				try {					if (authToken != null) {						isValidToken = authAPI.isValidToken(authToken);					}				} catch (Exception e) {					//Adding try/catch block because isValidToken method does not return false if 					//the token is invalid. Instead it throws an exception!!										LOGGER.debug("Error while validating passed in token. Authenticating again. If the user is AD or SAML enabled, then this will fail");				}								if (! isValidToken) {					identity = authAPI.authenticate(credentials,APIConstants.UI_CLIENT);					authToken = identity.getAuthenticationToken();				}								credentials.put(JAASConstants.LOGIN_NAME, identity.getLoginName());			} else {								authToken = (AuthenticationToken) credentials.get(JAASConstants.JC_AUTH_TOKEN);								if (! authAPI.isValidToken(authToken)) {										LOGGER.error("Invalid token to get instance details");										throw new SecurityException(SecurityFaultCode.INVALID_TOKEN);				}											}			LOGGER.info(" authToken value in JCLoginModule class "+ authToken);			UserAPI userAPI = JCAPIFactory.getUserAPI(authToken);			UserSearchInfo userSearchInfo = new UserSearchInfo();			userSearchInfo.setCompanyID(authToken.getCompanyID());			userSearchInfo.setUserID(authToken.getUserID());			userSearchList = userAPI.getUsers(userSearchInfo);			Iterator usrSearchIterator = userSearchList.iterator();			if (usrSearchIterator.hasNext()) {				usrShortInfo = (UserShortInfo) usrSearchIterator.next();			}		} catch (Exception e) {			ArrayList<String> errors = new ArrayList<String>();			LOGGER.error(" Error message in JCLoginModule class "					+ e.getMessage());			errors.add(e.getMessage());			JCDynamicFaultCode dynaFault =  new JCDynamicFaultCode(					SecurityFaultCode.LOGIN_FAILURE, errors);			LOGGER.error(" Error message in JCLoginModule class "+e.getClass().getName()+e.toString());			/*			 * change for throwing the error message generated during authentication to Active Directory			 * It catches  the JCAPiException and compare with FaultCode to identify if it is AD Authentication Error 			 */			if(e instanceof JCApiException)			{				LOGGER.error(" api exception "+SecurityFaultCode.AD_AUTH_ERROR.getCode());				JCApiException e1 = (JCApiException)e;				LOGGER.error(" api exception "+e1.getErrorCode().getCode());				/*if(e1.getErrorCode().getCode().equals(SecurityFaultCodes.AD_AUTH_ERROR.getCode()))				{					errors = new ArrayList<String>();					errors.add(e1.getMessage());					dynaFault =  new JCDynamicFaultCode(							SecurityFaultCode.AD_AUTH_ERROR, errors);						LOGGER.error(" inside api exception "+dynaFault.getCode()+" and "+dynaFault.getFaultCode());					throw new SecurityException(dynaFault);				}*/			}						throw new SecurityException(dynaFault, e.getCause());		}		if (LOGGER.isDebugEnabled()) {			LOGGER.debug(" LOGIN_SUCCESS value in isValidUser() Method "					+ LOGIN_SUCCESS);		}		if (LOGGER.isDebugEnabled()) {			LOGGER.debug(" end isValidUser() Method of JCLoginModule ");		}		return LOGIN_SUCCESS;	}	}